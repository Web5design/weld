<html><head>

  <link charset="utf-8" title="no title" media="screen" type="text/css" href="demo/css/index.css" rel="stylesheet">
  <link href="/index.xml" title="app - feed" type="application/atom+xml" rel="alternate"><meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <title>weld.js, templating antimatter</title></head>  
   
  <body> 
    <section> 
      <header id="main"> 
      <div class="content"> 
        <section id="intro"> 
          <div id="product">weld<span class="extra">js</span></div><br/>
          <div id="flourish"></div>
        </section> 
        <div id="icons">
          <div id="icon1" class="icon">JSON</div>
          <div id="icon2" class="icon">markup</div>
          <div id="icon3" class="icon">instructions</div>
        </div>
        <div id="blabber">
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
        </div>
      <div style="clear: both"></div> 
    </header> 
 
    <section id="menu" style="top: 470px; position: absolute;" class=""> 
      <div class="content"> 
        <nav> 
          <a href="#intro">intro</a> 
          <a id="guide-link" href="#docs">guide</a> 
          <a href="#installing">installing</a> 
          <a href="#reference">reference</a> 
          <a href="#about">about</a> 
          <a href="http://github.com/cloudhead/vows">source <img src="/images/github.ico" id="github"></a> 
        </nav> 
        <div id="dropdown"> 
          <ul> 
            <li><a href="#-structure-of-a-test-suite">Structure of a Test Suite</a></li> 
            <li><a href="#-how-topics-work">How topics work</a></li> 
            <li><a href="#-running-a-suite">Running a Suite</a></li> 
            <li><a href="#-writing-asynchronous-tests">Asynchronous Testing</a></li> 
            <li><a href="#-assertions">Assertions</a></li> 
            <li><a href="#-macros">Macros</a></li> 
          </ul>
        </div>
      </div>
    </section>

    <section id="synopsis">
      <div class="content">
        <h1>Synopsis</h1>
        Weld binds data to markup, and can generate markup based on your data. There's NO special syntax or 
        data reshaping required. It works in the browser and in node.js! Weld is currently 3.66Kb uglified with
        no dependencies other than a valid DOM. Weld will apply values to elements the way that elements expect 
        to have their values set.
     </div>
    </section>

    <section id="demos">
      <div class=>
    </section>
 
  </div> 
</section> 
 
<section id="docs"> 
  <div class="content"> 
      <h1>Guide</h1> 
 
<h2 id="-structure-of-a-test-suite">Repeating data</h2> 

<div class="sandbox">
  <div class="js">

<textarea id="codeSample1" name="codeSample1">
weld($('.contact', container)[0], data, { 
  alias: { 
    name : function(parent, element, key, value) { 
      // Sanity
      test.ok(key === 'name');

      return $('.foo', element)[0];
    }
  }
});
</textarea>

  </div>
  <div class="html">

<textarea id="htmlSample1" name="htmlSample1">
<ul class="contacts" style="display: none">
  <li class="contact">
    <span class="name">My Name</span>
    <p class="title">Leet Developer</p>
  </li>
</ul>
</textarea>

  </div>
  <div class="json">
    
<textarea id="jsonSample1" name="jsonSample1">
[
  { 
    "name": "hij1nx",
    "title": "code exploder"
  },
  { 
    "name": "tmpvar", 
    "title": "code pimp"
  }
]
</textarea>

    
  </div>
  <div class="result"></div>
</div>


<h2 id="-how-topics-work">How topics work</h2> 
 
<p>Understanding <em>topics</em> is one of the keys to understanding Vows. Unlike other testing frameworks,
Vows forces a clear separation between the element which is tested, the <em>topic</em>, and the actual tests, the <em>vows</em>.</p> 
 
<p>Let’s start with a simple example of a context:</p> 
 
<pre><code>{ topic: 42,
  'should be equal to 42': function (topic) {
    assert.equal (topic, 42);
  }
}
</code></pre> 
 
<p>So this shows us that the value of the topic is passed down to our test function (refered to as a <em>vow</em> from now on) as an argument.
Simple enough. Now let’s look at an equivalent example, written differently:</p> 
 
<pre><code>{ topic: function () { return 42 },
  'should be equal to 42': function (topic) {
    assert.equal (topic, 42);
  }
}
</code></pre> 
 
<p>Same thing. Topics can be functions too. The return value becomes the topic. Now what if we have multiple vows?</p> 
 
<pre><code>{ topic: function () { return 42 },
  'should be a number': function (topic) {
    assert.isNumber (topic);
  },
  'should be equal to 42': function (topic) {
    assert.equal (topic, 42);
  }
}
</code></pre> 
 
<p>It works as expected, the value is passed down to each <em>vow</em>. Note that the topic function is <strong>only run once</strong>.</p> 
 
<h3>Scope</h3> 
 
<p>Sometimes, you might need a parent topic’s value, from inside a child topic. This is easy, because there is
a notion of topic <em>scope</em>. Let’s look at an example:</p> 
 
<pre><code>{ topic: new(DataStore),
  'should respond to `get()` and `put()`': function (store) {
    assert.isFunction (store.get);
    assert.isFunction (store.put);
  },
  'calling `get(42)`': {
    topic: function (store) { return store.get(42) },
    'should return the object with id 42': function (topic) {
      assert.equal (topic.id, 42);
    }
  }
}
</code></pre> 
 
<p>In the example above, the value of the top-level topic is passed as an argument to the inner topic, in the same manner
it’s passed to the vows. For clarity, I named both arguments which refer to the outer topic as <code>store</code>.</p> 
 
<p>Note that the scoping isn’t limited to a single level. Consider:</p> 
 
<pre><code>topic: function (a, /* Parent topic                     */
                 b, /* Parent of parent topic           */
                 c  /* Parent of parent of parent topic */) {}
</code></pre> 
 
<p>So the parent topics are passed along to each topic function in the certain order: the immediate parent is always the first
argument (<code>a</code>), and the outer topics follow (<code>b</code>, then <code>c</code>), like the layers of an onion.</p> 
 
<h2 id="-running-a-suite">Running a suite</h2> 
 
<p>The simplest way to run a test suite, is with the <code>run</code> method:</p> 
 
<pre><code>vows.describe('subject').addBatch({/* ... */}).run();
</code></pre> 
 
<p>The <code>run</code> method takes an optional callback, which is called when all tests are done running.
The test results are passed to the callback (if provided), as an object:</p> 
 
<pre><code>{ honored: 145,
  broken:    4,
  errored:   1,
  pending:   0,
  total:   150,
  time:  5.491
};
</code></pre> 
 
<p>Now if we want to execute this test suite, assuming it’s in <em>subject-test.js</em>, we just do:</p> 
 
<pre><code>$ node subject-test.js
</code></pre> 
 
<p>The results will be printed to the console with the default reporter, <code>'dot-matrix'</code>.</p> 
 
<h3>Exporting the suite</h3> 
 
<p>When your tests become more complex, spanning multiple files, you’re going to need a way to run
them as a single entity.</p> 
 
<p>Vows has a test runner called <code>vows</code>, which you can use to run multiple test suites at once.
To make use of it, you need to export your tests, instead of just running them. There’s a couple
of ways to do that, the easiest is through the <code>export</code> method:</p> 
 
<pre><code>// subject-test.js
 
vows.describe('subject').addBatch({/* ... */}).export(module);
</code></pre> 
 
<p><code>export</code> takes one argument, the module you want to export the test suite to. Fortunately,
node provides a global variable called <code>module</code>, which is a reference to the current module.</p> 
 
<p>Now to run that file with the test runner, we can do:</p> 
 
<pre><code>$ vows subject-test.js
</code></pre> 
 
<p>The result should be identical to running it directly with <code>node</code>. The difference is that we can now do:</p> 
 
<pre><code>$ vows test/*
</code></pre> 
 
<p>to run all the tests in our <em>test/</em> folder, and get combined results. We can also pass options to <code>vows</code>.
For example, to get a “spec style” output, pass the <code>--spec</code> flag. The reference section has more information on
the different options you can pass to it.</p> 
 
<p>Another way to export your test suites is by simply adding them to the <code>exports</code> object, the same way you would export
an API to a library:</p> 
 
<pre><code>exports.suite1 = vows.describe('suite one');
exports.suite2 = vows.describe('suite two');
</code></pre> 
 
<h3>So let’s recap</h3> 
 
<pre><code>// subject-test.js
// A test suite, describing 'subject'
 
vows.describe('subject') // Create the suite, describing 'subject'
    .addBatch({})        // Add the 1st batch
    .addBatch({})        // Add a 2nd batch
    .addBatch({})        // Add a 3rd batch
    .export(module);     // Export it
</code></pre> 
 
<h2 id="-writing-asynchronous-tests">Writing asynchronous tests</h2> 
 
<blockquote><p>Before diving into asynchronous testing, make sure you read the section about <em>topics</em>.</p></blockquote> 
 
<p>Let’s say we want to test that a certain file exists, and satisfies a couple criteria.</p> 
 
<p>As you know, we don’t ‘return’ a value from an asynchronous function call&mdash;the value is
passed to the callback function. So how can we do that with <em>topics</em>? Take a look:</p> 
 
<pre><code>{ topic: function () {
    fs.stat('~/FILE', this.callback);
  },
  'can be accessed': function (err, stat) {
    assert.isNull   (err);        // We have no error
    assert.isObject (stat);       // We have a stat object
  },
  'is not empty': function (err, stat) {
    assert.isNotZero (stat.size); // The file size is &gt; 0
  }
}
</code></pre> 
 
<p>The key here is the special ‘<code>this.callback</code>’ function, which is available inside all topics.</p> 
 
<p>When <code>this.callback</code> is <em>called</em>, it passes on the arguments it received to the test functions,
one by one, as if the values were returned by the topic function itself.</p> 
 
<p>In essence, this allows us to decouple the callback from the async function call.</p> 
 
<p>This is how Vows keeps track of all the asynchronous calls, and can warn you if something
hasn’t returned.</p> 
 
<blockquote><p>Note that topics which make use of ‘<code>this.callback</code>’ must not return anything. And likewise, topics
which do not return anything must make use of ‘<code>this.callback</code>’.</p></blockquote> 
 
<h3>Promises</h3> 
 
<p>Vows also supports promise-based async out of the box, so if that works better for your purpose,
you can return an instance of <code>EventEmitter</code> from a topic, and the tests will be run when it
emits a <code>"success"</code> or <code>"error"</code> event:</p> 
 
<pre><code>{ topic: function () {
    var promise = new(events.EventEmitter);
 
    fs.stat('~/FILE', function (e, res) {
        if (e) { promise.emit('error', e) }
        else   { promise.emit('success', res) }
    });
    return promise;
  },
  'can be accessed': function (err, stat) {
    assert.isNull   (err);        // We have no error
    assert.isObject (stat);       // We have a stat object
  },
  'is not empty': function (err, stat) {
    assert.isNotZero (stat.size); // The file size is &gt; 0
  }
}
</code></pre> 
 
<h3>Order of execution and parallelism</h3> 
 
<p>We talked about how batches and contexts are executed briefly,
but it’s now time to delve into it in more detail:</p> 
 
<pre><code>{ topic: function () {
    fs.stat('~/FILE', this.callback);
  },
  'after a successful `fs.stat`': {
    topic: function (stat) {
      fs.open('~/FILE', "r", stat.mode, this.callback);
    },
    'after a successful `fs.open`': {
      topic: function (fd, stat) {
        fs.read(fd, stat.size, 0, "utf8", this.callback);
      },
      'we can `fs.read` to get the file contents': function (data) {
        assert.isString (data);
      }
    }
  }
}
</code></pre> 
 
<p>In the example above, we make use of nested contexts to mimic nested callbacks. As you can tell,
the result of the parent topic is passed down to its children, as arguments.</p> 
 
<p>This example as a whole is therefore mostly sequential, while remaining asynchronous.</p> 
 
<hr> 
 
<p>Now let’s look at an example which uses parallel tests to check for some devices:</p> 
 
<pre><code>{ '/dev/stdout': {
    topic:    function () { path.exists('/dev/stdout', this.callback) },
    'exists': function (result) { assert.isTrue(result) }
  },
  '/dev/tty': {
    topic:    function () { path.exists('/dev/tty', this.callback) },
    'exists': function (result) { assert.isTrue(result) }
  },
  '/dev/null': {
    topic:    function () { path.exists('/dev/null', this.callback) },
    'exists': function (result) { assert.isTrue(result) }
  }
}
</code></pre> 
 
<p>So in this case, the tests can finish in any order, and must not rely on each other. The test
suite will exit when the last I/O call completes, and the assertions for it are run.</p> 
 
<p>In other words, <em>sibling contexts</em> are executed in parallel, while <em>nested contexts</em> are
executed sequentially. Note that this all happens asynchronously, so while some contexts
may be waiting for a parent context to finish, sibling contexts can still execute in the meantime.</p> 
 
<h2 id="-assertions">Assertions</h2> 
 
<p>Vows extends the assertion module which comes bundled with node, with many useful functions,
as well as better error reporting for the existing ones.</p> 
 
<p>It’s always best to use the more specific assertion functions when testing a value,
you’ll get much better error reporting, because your intention is clearer.</p> 
 
<p>Let’s say we have the following array:</p> 
 
<pre><code>var ary = [1, 2, 3];
</code></pre> 
 
<p>and try to assert that it has 5 elements. With the built-in <code>assert.equal</code>,
we would do something like this:</p> 
 
<pre><code>assert.equal(ary.length, 5);
</code></pre> 
 
<p>And get the following error:</p> 
 
<pre><code>expected 5, got 3
</code></pre> 
 
<p>Now let’s try that with one of our more specific assertion functions, <code>assert.length</code>:</p> 
 
<pre><code>assert.length(ary, 5);
</code></pre> 
 
<p>This reports the following error:</p> 
 
<pre><code>expected [1, 2, 3] to have 5 elements
</code></pre> 
 
<p>Other useful assertion functions bundled with vows include <code>assert.match</code>, <code>assert.instanceOf</code>,
<code>assert.include</code> and <code>assert.isEmpty</code>&mdash;head over to the <a href="/#reference">reference</a> to get the full list.</p> 
 
<h2 id="-macros">Macros</h2> 
 
<p>Sometimes, it’s useful to abstract tests which are used throughout the test suite. A <em>batch</em> in Vows,
is a tree-like data structure&mdash;an Object literal to be precise. This proves to be pretty powerful, as you’ll see.</p> 
 
<p>One of the things I have to test in the  majority of the code I write are HTTP status codes. So let’s first look
at the straightforward way of doing this, given an asynchronous <code>client</code> library:</p> 
 
<pre><code>{ topic: function () {
    client.get('/resources/42', this.callback);
  },
  'should respond with a 200 OK': function (e, res) {
    assert.equal (res.status, 200);
  }
}
</code></pre> 
 
<p>Not too bad. But we might have a hundred of these, if we’re testing an API. So let’s see what we can do with macros:</p> 
 
<pre><code>function assertStatus(code) {
    return function (e, res) {
        assert.equal (res.status, code);
    };
}
</code></pre> 
 
<p>This is a function which takes a status code, and returns a function which tests for that status code. We can now
improve our test like this:</p> 
 
<pre><code>{ topic: function () {
    client.get('/resources/42', this.callback);
  },
  'should respond with a 200 OK': assertStatus(200)
}
</code></pre> 
 
<p>Much better. How about the topic? Let’s write a macro for our API calls:</p> 
 
<pre><code>var api = {
    get: function (path) {
        return function () {
            client.get(path, this.callback);
        };
    }
};
</code></pre> 
 
<p>And rewrite our tests:</p> 
 
<pre><code>{ topic: api.get('/resources/42'),
  'should respond with a 200 OK': assertStatus(200)
}
</code></pre> 
 
<p>Fantastic. Here’s a an example of what these macros could look like:</p> 
 
<pre><code>{   'GET /': {
        topic: api.get('/'),
        'should respond with a 200 OK': assertStatus(200)
    },
    'POST /': {
        topic: api.post('/'),
        'should respond with a 405 Method not allowed': assertStatus(405)
    },
    'GET /resources (no api-key)': {
        topic: api.get('/resources'),
        'should respond with a 403 Forbidden': assertStatus(403)
    },
    'GET /resources?apikey=af816e859c249fe'
        topic: api.get('/resources?apikey=af816e859c249fe'),
        'should return a 200 OK': assertStatus(200),
        'should return a list of resources': function (res) {
            assert.isArray (res.body);
        }
    }
}
</code></pre> 
 
<p>Can we push it further? Of course we can, and this is when it gets <em>really</em> interesting. I’m going to
show you how you can generate contextual tests.</p> 
 
<p>Instead of having a separate function which generates a <em>topic</em>, and another one which generates
a <em>vow</em>, we’re going to have a function which generates a <em>context</em> which contains both a topic and a vow.</p> 
 
<p>The topic will perform a <em>contextual</em> request. This is the interesting part: we’re going to parse
the context description to generate the api requests. So the test will be encoded within its
description. Let’s look at a possible implementation:</p> 
 
<pre><code>//
// Send a request and check the response status.
//
function respondsWith(status) {
    var context = {
        topic: function () {
            // Get the current context's name, such as "POST /"
            // and split it at the space.
            var req    = this.context.name.split(/ +/), // ["POST", "/"]
                method = name[0].toLowerCase(),         // "post"
                path   = name[1];                       // "/"
 
            // Perform the contextual client request,
            // with the above method and path.
            client[method](path, this.callback);
        }
    };
    // Create and assign the vow to the context.
    // The description is generated from the expected status code
    // and status name, from node's http module.
    context['should respond with a ' + status + ' '
           + http.STATUS_CODES[status]] = assertStatus(status);
 
    return context;
}
</code></pre> 
 
<p>Now the first three contexts of our batch can be re-written as:</p> 
 
<pre><code>{ 'GET  /':                   respondsWith(200),
  'POST /':                   respondsWith(405),
  'GET  /resources (no key)': respondsWith(403)
}
</code></pre> 
 
<p>And when run, we get:</p> 
 
<div class="report"><pre class="report"> 
GET  /
  ✓ <span class="vow">should respond with a 200 OK</span> 
POST /
  ✓ <span class="vow">should respond with a 405 Method Not Allowed</span> 
GET  /resources (no key)
  ✓ <span class="vow">should respond with a 403 Forbidden</span> 
</pre></div> 
 
 
<p>The fourth context is a little more complex, as it has two vows, but I’ll let you figure that
one out!</p> 
 
  </div> 
</section> 
 
<section id="reference"> 
  <div class="content"> 
    <h1>Reference</h1> 
 
<p>The CLI and assertion module are documented here.</p> 
 
<h2>Test runner</h2> 
 
<pre><code>vows [FILE, ...] [options]
</code></pre> 
 
<p>Running specific tests</p> 
 
<pre><code>$ vows test-1.js test-2.js
$ vows tests/*
</code></pre> 
 
<p>Running all tests in your <em>test/</em> or <em>spec/</em> folder</p> 
 
<pre><code>$ vows
</code></pre> 
 
<p>Watch mode</p> 
 
<pre><code>$ vows -w
$ vows --watch
</code></pre> 
 
<hr> 
 
<h3>Options</h3> 
 
<table cellspacing="10"> 
  <tbody><tr> 
    <td><code>-v</code>, <code>--verbose</code></td> 
    <td>Verbose mode</td> 
  </tr> 
  <tr> 
    <td><code>-w</code>, <code>--watch</code></td> 
    <td>Watch mode</td> 
  </tr> 
  <tr> 
    <td><code>-m STRING</code></td> 
    <td>String matching: Only run tests with <code>STRING</code> in their title</td> 
  </tr> 
  <tr> 
    <td><code>-r REGEXP</code></td> 
    <td>Regexp matching: Only run tests with <code>REGEXP</code> in their title</td> 
  </tr> 
  <tr> 
    <td><code>--json</code></td> 
    <td>Use JSON reporter</td> 
  </tr> 
  <tr> 
    <td><code>--spec</code></td> 
    <td>Use Spec reporter</td> 
  </tr> 
  <tr> 
    <td><code>--dot-matrix</code></td> 
    <td>Use Dot-Matrix reporter</td> 
  </tr> 
  <!-- <tr> --> 
  <!--   <td><code>-no-color</code></td> --> 
  <!--   <td>Don't use terminal colors</td> --> 
  <!-- </tr> --> 
  <tr> 
    <td><code>--version</code></td> 
    <td>Show version</td> 
  </tr> 
  <tr> 
    <td><code>-s</code>, <code>--silent</code></td> 
    <td>Don't report</td> 
  </tr> 
  <tr> 
    <td><code>--help</code></td> 
    <td>Show help</td> 
  </tr> 
</tbody></table> 
 
 
<h2>Assertion functions</h2> 
 
<h3>equality</h3> 
 
<pre><code>assert.equal          (4, 4);
assert.strictEqual    (4 &gt; 2, true);
 
assert.notEqual       (4, 2);
assert.strictNotEqual (1, true);
 
assert.deepEqual      ([4, 2], [4, 2]);
assert.notDeepEqual   ([4, 2], [2, 4]);
</code></pre> 
 
<h3>type</h3> 
 
<pre><code>assert.isFunction (function () {});
assert.isObject   ({goo:true});
assert.isString   ('goo');
assert.isArray    ([4, 2]);
assert.isNumber   (42);
assert.isBoolean  (true);
 
assert.typeOf     (42, 'number');
assert.instanceOf ([], Array);
</code></pre> 
 
<h3>truth</h3> 
 
<pre><code>assert.isTrue  (true);
assert.isFalse (false);
</code></pre> 
 
<h3>null, undefined, NaN</h3> 
 
<pre><code>assert.isNull      (null);
assert.isNotNull   (undefined);
 
assert.isUndefined ('goo'[9]);
assert.isNaN       (0/0);
</code></pre> 
 
<h3>inclusion</h3> 
 
<pre><code>assert.include ([4, 2, 0], 2);
assert.include ({goo:true}, 'goo');
assert.include ('goo', 'o');
</code></pre> 
 
<h3>regexp matching</h3> 
 
<pre><code>assert.match ('hello', /^[a-z]+/);
</code></pre> 
 
<h3>length</h3> 
 
<pre><code>assert.length ([4, 2, 0], 3);
assert.length ('goo', 3);
</code></pre> 
 
<h3>emptiness</h3> 
 
<pre><code>assert.isEmpty ([]);
assert.isEmpty ({});
assert.isEmpty ("");
</code></pre> 
 
<h3>exceptions</h3> 
 
<pre><code>assert.throws(function () { x + x }, ReferenceError);
assert.doesNotThrow(function () { 1 + 1 }, Error);
</code></pre> 
 
  </div> 
</section> 
 
<section id="about"> 
  <div class="content"> 
    <h1>About</h1> 
 
<p>weld was developed by <a href="http://github.com/hij1nx">hij1nx</a> and <a href="http://github.com/tmpvar">tmpvar</a>, and has had many <a href="http://github.com/hij1nx/weld/package.json">contributors</a>.</p> 
 
    <footer> 
        <p>powered by <a href="http://cloudhead.io/toto">toto</a>, <a href="http://github.com/cloudhead/less.js">LESS</a> and <a href="http://github.com/cloudhead/hijs">hijs</a></p> 
        <p id="copy">Copyright &copy; Alexis Sellier 2010</p> 
    </footer> 
  </div> 
</section> 
 
<a href="http://github.com/hij1nx/weld"> 
  <img alt="Fork me on GitHub" src="img/forkme_left_blueish_ff7600.png" style="position: absolute; z-index: 5; top: 0; left: 0; border: 0;"> 
</a>
 
<script src="demo/js/codemirror.js" type="text/javascript" charset="utf-8"></script>
<script charset="utf-8" type="text/javascript" src="demo/js/index.js"></script> 

</body>
</html>
